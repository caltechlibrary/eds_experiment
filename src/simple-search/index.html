<html>
  <head>
    <title>EDS API experiment</title>

    <script type="text/javascript" src="https://unpkg.com/vue"></script>
    <script type="text/javascript" src="https://unpkg.com/vue-spinners"></script>
    <link rel="stylesheet" href="https://unpkg.com/vue-spinners/dist/vue-spinners.css">
    <script type="text/javascript" src="https://unpkg.com/vue-select"></script>
    <link rel="stylesheet" href="https://unpkg.com/vue-select@latest/dist/vue-select.css">

    <!-- Load general JavaScript dependencies. -->

    <script type="text/javascript" src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/loglevel"></script>
    <script type="text/javascript" src="https://unpkg.com/loglevel-plugin-prefix"></script>
    <script type="text/javascript" src="https://unpkg.com/he"></script>
    <script type="text/javascript" src="https://unpkg.com/humanize-plus"></script>

    <!-- Our app. -->

    <!-- Next line is to make syntax here and in node -->
    <script type="text/javascript">module = {}</script>
    <script type="text/javascript" src="app-settings.js"></script>
    <script type="text/javascript" src="lib/log.js"></script>
    <script type="text/javascript" src="lib/net.js"></script>
    <script type="text/javascript" src="lib/string.js"></script>

    <link rel="stylesheet" href="app.css"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Heebo:400,400italic,500,500italic,700|Roboto:400,400italic,500,500italic,700|IBM+Plex+Mono:400,400italic,500,500italic">
  </head>
  <body>
    <div id="app">
      <div class="app-wrapper">
        <h1>Search the EBSCO Discovery Service</h1>
        <input v-model="searchString" v-on:keyup.enter="run"
               class="search-input" type="text" placeholder="Search string"/>

        <div class="options">
          <span id="select-sort">Sort results:
            <v-select v-model="sortMode" :options="sortOptions" class="select-sort"></v-select>
          </span>

          <div class="labeled-checkbox">
            <input v-model="highlightTerms" type="checkbox" id="optionHighlight"/>
            <label for="optionHighlight" class="search-option">
              Highlight search terms in results?
            </label>
          </div>

          <div class="labeled-checkbox">
            <input v-model="autocorrect" type="checkbox" id="optionAutocorrect"/>
            <label for="optionAutocorrect" class="search-option">
              Let EBSCO autocorrect spelling?
            </label>
          </div>
        </div>

        <button v-on:click="run" class="search-button">Search</button>

        <modal v-if="errorEmptyString" v-on:close="errorEmptyString = false">
          <span slot="header">Error</span>
          <span slot="body">Cannot search for an empty string.</span>
        </modal>

        <div class="output">
          <span class="search-status">
            {{ searchStatus }}<circ v-if="isSearching"></circ>
          </span>
          <span class="num-results">{{ numResults }}</span>
          <div class="results-table">
            <ul class="results-list">
              <li v-for="record in records">
                <div class="pub-record">
                  <div class="pub-title">
                    <span v-html="pubTitle(record)"></span>
                  </div>
                  <div class="pub-authors">
                    <span v-html="pubAuthors(record)"></span>
                  </div>
                  <div class="pub-source-type">
                    <span v-html="pubType(record)"></span>
                  </div>
                  <div class="pub-source">
                    <span v-html="pubSource(record)"></span>
                  </div>
                  <div class="pub-doi">
                    <a v-bind:href="pubURL(record)" v-html="pubDOI(record)"></a>
                  </div>
                </div>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <script>

     // Global configuration.
     // .......................................................................

     // Set the logging level.  Use 'trace' for debugging, 'warn' for normal.
     log.setDefaultLevel('trace');

     // How long to wait on axios http post, in milliseconds.
     const postTimeout = 5 * 1000;


     // Main code.
     // .......................................................................

     Vue.component('circ', VueSpinners.CircleSpinner);
     Vue.component('v-select', VueSelect.VueSelect);

     Vue.component("modal", {
       template: `
      <transition name="modal">
        <div class="modal-mask">
          <div class="modal-wrapper">
            <div class="modal-container">
              <div class="modal-header"><slot name="header"></slot></div>
              <div class="modal-body"><slot name="body"></slot></div>
              <div class="modal-footer">
                <button id="ok-button" class="modal-default-button"
                  v-on:click="$emit('close')" v-on:keydown.esc="$emit('close')">
                  OK
                </button>
              </div>
            </div>
          </div>
        </div>
      </transition>`,
       mounted: function() {
         // Put focus on the button by default.
         document.getElementById("ok-button").focus();
       }
     });

     // Define our Vue application.
     new Vue({
       el: '#app',
       data: {
         errorEmptyString: false,
         searchString: '',
         highlightTerms: true,
         autocorrect: true,
         searchStatus: '',
         numResults: '',
         records: [],
         isSearching: false,
         sortOptions: ['relevance', 'date'],
         sortMode: 'relevance',
       },
       methods: {

         // Helper functions.
         // ...................................................................

         authToken() {
           let body = JSON.stringify({ "UserId": config.user,
                                       "Password": config.password });
           log.debug('getting authentication token');
           return net.post(config.authURL, config.corsproxy, body)
                     .then(data => data.AuthToken);
         },

         sessionToken(a_token) {
           log.debug('getting session token');
           return net.post(config.sessionURL, config.corsproxy,
                           {'Profile': 'edsapi'},
                           {'x-authenticationToken': a_token })
                     .then(data => data.SessionToken);
         },

         searchResults(a_token, s_token) {
           let headers = {'x-authenticationToken': a_token,
                          'x-sessionToken': s_token,
                          'Content-Type': 'application/json' };
           let body = {
             "SearchCriteria": {
               "Queries": [ { "Term": this.searchString } ],
               "SearchMode": "all",
               "IncludeFacets": "y",
               "Sort": this.sortMode,
               "AutoSuggest": "n",
               "AutoCorrect": this.autocorrect ? "y" : "n",
             },
             "RetrievalCriteria": {
               "View": "brief",
               "ResultsPerPage": 20,
               "PageNumber": 1,
               "Highlight": this.highlightTerms ? "y" : "n",
               "IncludeImageQuickView": "n"
             },
             "Actions": null
           };
           log.debug('sending search query');
           return net.post(config.searchURL, config.corsproxy, body, headers)
                     .then(data => data.SearchResult);
         },

         pubTitle(record) {
           if (record.hasOwnProperty('Items')) {
             for (var item of record.Items) {
               if (item.Label === 'Title') {
                 let htmlified = he.decode(item.Data);
                 htmlified = htmlified.replaceAll(/<highlight>/i, '<span class="highlight">');
                 htmlified = htmlified.replaceAll(/<\/highlight>/i, '</span>');
                 return htmlified;
               };
             };
             log.warn('Record has no Title item');
             return '';
           } else {
             log.warn('Record has no Items array');
             return '';
           }
         },

         pubAuthors(record) {
           // Not everything has an authors field.
           if (record.hasOwnProperty('Items')) {
             for (var item of record.Items) {
               if (item.Label === 'Authors') {
                 let htmlified = he.decode(item.Data);
                 htmlified = htmlified.replaceAll(/<searchlink.*?>(.+?)<\/searchlink>/i,
                                                  '<span class="author">$1</span>');
                 htmlified = htmlified.replaceAll(/<relatesto.*?>(.+?)<\/relatesto>/i, '');
                 htmlified = htmlified.replaceAll(/<superscript>(.+?)<\/superscript>/i, '');
                 htmlified = htmlified.replaceAll(/<i>(.+?)<\/i>/i, '');
                 htmlified = htmlified.replace(/ \(AUTHOR\)/gi, ' ');
                 htmlified = htmlified.replace(/, Editor/gi, ' ');
                 htmlified = htmlified.replace(/, Series Editor/gi, ' ');
                 htmlified = htmlified.replace(/<br ?\/?>/gi, ' ');
                 return htmlified;
               }
             };
             this.warnMissing(record, 'Authors');
             return '';
           } else {
             log.warn('Record has no Items array');
             return '';
           }
         },

         pubSource(record) {
           // Not everything has an authors field.
           if (record.hasOwnProperty('Items')) {
             for (var item of record.Items) {
               if (item.Label === 'Source') {
                 let htmlified = he.decode(item.Data);
                 return htmlified;
               }
             };
             this.warnMissing(record, 'Source');
             return '';
           } else {
             log.warn('Record has no Items array');
             return '';
           }
         },

         pubType(record) {
           // Not everything has an authors field.
           if (record.hasOwnProperty('Header')) {
             return record.Header.PubType;
           } else {
             this.warnMissing(record, 'Header');
             return '';
           }
         },

         pubURL(record) {
           // Not everything has an authors field.
           if (record.hasOwnProperty('PLink')) {
             return record.PLink;
           } else {
             this.warnMissing(record, 'PLink');
             return '';
           }
         },

         pubDOI(record) {
           // Not everything has an authors field.
           if (! record.hasOwnProperty('RecordInfo')) {
             this.warnMissing(record, 'RecordInfo');
             return '';
           };
           if (! record.RecordInfo.hasOwnProperty('BibRecord')) {
             this.warnMissing(record, 'RecordInfo.BibRecord');           
             return '';
           };
           if (! record.RecordInfo.BibRecord.hasOwnProperty('BibEntity')) {
             this.warnMissing(record, 'RecordInfo.BibRecord.BibEntity');
             return '';
           };
           let entity = record.RecordInfo.BibRecord.BibEntity;
           for (var item of entity.Identifiers) {
             if (item.Type === 'doi')
               return item.Value;
           }
           return '';
         },

         setSortMode(mode) {
           this.sortMode = mode;
           log.debug(`${mode} sort mode selected`);
         },

         warnMissing(record, field) {
             if (record.hasOwnProperty('Items') && record.Items[0].Label === 'Title')
               log.warn('record has no ' + field + ': ' + record.Items[0].Data);
             else
               log.warn('record with no RecordInfo encountered');
         },


         // Main body.
         // ...................................................................

         run() {
           // Sanity checks.

           if (! this.searchString) {
             log.debug('empty search string');
             this.errorEmptyString = true;
             return false;
           }

           // Set up state for a new search.

           log.debug('clearing state and starting a search')
           this.records = [];
           this.numResults = '';
           this.searchStatus = 'Searching for "' + this.searchString + '" ...';
           this.isSearching = true;

           // Let's do this thing.

           let authTokenPromise = this.authToken();

           let sessionTokenPromise = authTokenPromise.then(
             (atok) => {
               return this.sessionToken(atok);
             });

           let searchPromise = Promise.all([authTokenPromise, sessionTokenPromise]).then(
             (tokens) => {
               return this.searchResults(tokens[0], tokens[1]);
             });

           let items = searchPromise.then(
             (results) => {
               log.debug('results received');
               this.isSearching = false;
               this.searchStatus = 'Searching for "' + this.searchString + '" ... Done.';
               console.log(results);
               stats = results.Statistics;
               this.numResults = 'Total number of hits: '
                               + Humanize.intComma(stats.TotalHits) + '.';
               this.records = results.Data.Records;
               console.log(this.numResults);
             });
         },
       }
     })
    </script>
  </body>
</html>
